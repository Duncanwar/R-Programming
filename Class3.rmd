---
title: "Class3"
author: "Duncan"
date: "2025-10-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results=TRUE)
```

# CLASS 2 CONTINUATION
# Control Structure
# Grouping 
## function on R
```{r}
f<-function(x) x^2
formals(f)
body(f)
environment(f)
```
## ifelse(test,yes,No)
```{r}
pvalues<-c(.867,0.0054,0.0018,0.1572,0.0183,0.5386) 
results<-ifelse(pvalues<0.05,"Significant"," Not significant") 
results
x<-runif(1,0,10)
if(x>3){
y<-10 }else {
y<-0
}
```
```{r}
y<-if (x>3){ 10
}else { 0
}
```
#####for
```{r}
for(i in 1:10){
print(i) }
x<-c("a","b","c","d")
x[3]
for(i in 1:5){
print(x[i]) }
for(i in 1:5)print(1:i)
for(i in 5:1)print(1:i)
```
## while Loops
```{r}
count<-1
while (count<10){
print(count)
count<-count+1
}
z<-5
set.seed(1)
while(z>= 3 && z<=10){
    coin<-rbinom(1,1,0.5) 
    if (coin==1){
        z=z+1
    } else 
          {z<-z-1 }
}
print(z)
```
## next,break
```{r}
for (i in 1:100){ print(1:i)
if (i>20){
break
} }
```
# function
functionname<-function(parameters){ statements return(value) } f1<-function(x){ result<-x^2+2 return(result) }
f2<-function(x,y){ result<-x2+y2-4 return(result) }

```{r}
f<-function(x,y){ result<-x+(2*y)+3
return(result) }
f(2,3)
```
# Exercise
Make a function to calculate two sample t test
## Applying functions to matrices and data frame.
```{r}
a<-4 
sqrt(4)
b<- c(1,243,5.754,2.987)
round(b)
c<-matrix(runif(12),nrow=3) 
c
log(c)
mean(c)
```
# lapply function
```{r}
fix_missing<-function(x){ x[x==-99]<-NA
x }
function1<-function(x){
x^2 }
curve(function1,-4,4)
```
#sapply
# titanic
```{r}
str(Titanic)
knitr::kable(Titanic)
apply(Titanic,c(1,2),sum )
options(digits = 2) 
apply(Titanic,c(1,2),sum)[3:4,]
apply(Titanic,c(1,4),sum)[3:4,]
apply(Titanic,c(1,2,4),sum)
apply(Titanic,c(1,2,4),sum)[3:4,,]
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,]

ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,]
digit=2
prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,], margin = 2)
prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,], margin = 2)
matrix(prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,], margin = 2),nrow = 2, dimnames = list(dimnames(Titanic)$Survived,dimnames (Titanic)$Sex))
matrix(prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,], margin = 2),nrow = 2, dimnames = list(dimnames(Titanic)$Survived,dimnames (Titanic)$Sex))
### Create dataset
Student<-c("John ncuti", "Angela bakame", "Bruce wizeye","Alexis aganze ", "claude Rukundo", "Joel Kagabo", "Mary ineza")
Math<-c(600,412,358,495,512,410,522)
Science<-c(95,99,80,82,75,89,77)
English<-c(25,22,18,20,29,30,27) 
roster<-data.frame(Student,Math,Science,English,stringsAsFactors = FALSE)
### standardize variables and obtains the performance scores because th ey are reported on different scale( With widely differing means and sta ndard deviations, we need to make them comparable before we combine the m.)
z<-scale(roster[,2:4])
### performance of each students using rowmeans and adding them to ros ter using cbind()
score<-apply(z,1,mean)
roster<-cbind(roster,score)
### Grades the students: quantile function gives the percentile rank o f each student's performance score check the cutoff of A y<-quantile(score,c(.8,.6,.4,.2))
## create a grade variable us
roster$grade[score>=y[1]]<-"A"
roster$grade[score<y[1]&score>=y[2]]<-"B"
roster$grade[score<y[2]& score>=y[3]]<-"C" 
roster$grade[score<y[3]& score>=y[4]]<-"D" 
roster$grade[score<y[4]]<-"F"
#### Dealing with names
name<-strsplit((roster$Student),"") 
lastname<-sapply (name,"[",2) 
firstname<-sapply(name,"[",1) 
roster<-cbind(firstname, lastname,roster[,-1])
roster<-roster[order(lastname,firstname),] 
roster
```
## Aggregation  and reshaping
### transpose
```{r}
cars<-mtcars[1:5, 1:4]
cars
t(cars)
```
### aggregate data
```{r}
options(digits=3)
attach(mtcars)
aggdata<-aggregate(mtcars,by=list(cyl,gear),FUN=mean,na.rm=TRUE)
```
```{r}
options(digits=3)
attach(mtcars)
aggdata<-aggregate(mtcars,by=list(cyl,gear),FUN=mean,na.rm=TRUE)
```
# Reshape
Step 1: install the package reshape2 step 2: melt data step 3: Cast the melted data into any shape you desire
Reshape
During the cast, you can aggregate the data with any function you wish.
```{r}
id<-c(1,1,2,2)
time<-c(1,2,1,2)
x1<-c(5,3,6,2)
x2<-c(6,5,1,4) 
mydata<-data.frame(id,time,x1,x2)
```
